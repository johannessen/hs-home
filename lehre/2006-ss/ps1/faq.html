<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML LANG="de"><HEAD>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
	<LINK REV="made" HREF="mailto:joar0011&#64;hs-karlsruhe.de" TITLE="E-Mail an Arne Johannessen">
	<LINK REL="contents" HREF="../../" TITLE="Arne Johannessen an der Hochschule Karlsruhe">
	<LINK REL="start" REV="start" HREF="http://www.home.hs-karlsruhe.de/~joar0011/ss06/ps1-t/">
	<TITLE>Fragen und Antworten – Tutorium Programmiersprachen I – SS 2006</TITLE>
	<STYLE TYPE="text/css">
@import url("screen.css");
H3 {
	margin-top: 4em;
}
H3#toc {
	margin-top: 1em;
}
H3#methoden {
	margin-top: 2.5em;
}
SAMP, VAR {
	font-family: inherit;
}
	</STYLE>
</HEAD><BODY ID="www-home-hs-karlsruhe-de-joar0011-ss06-ps1-t">

<DIV CLASS="hide">Zum <A HREF="#menu" ACCESSKEY="2">Menü</A> springen.</DIV>
<DIV ID="head"><H1>Tutorium bei Arne Johannessen – Programmiersprachen I</H1></DIV>

<H2 ID="aufgabe_4-3">Antworten zu Kapitel 4 Aufgabe 3</H2>

<H3 ID="toc">Inhaltsverzeichnis</H3>
<OL>
	<LI><A HREF="#methoden">Methoden</A></LI>
	<LI><A HREF="#array-syntax">Arrays – Syntax, Verwendung, sonstiges</A></LI>
	<LI><A HREF="#array-indizes">Arrays – Indizes, Grenzen</A></LI>
	<LI><A HREF="#oop">Klassen, Objekte, Datentypen</A></LI>
	<LI><A HREF="#pakete">Pakete</A></LI>
	<LI><A HREF="#skript">Fragen zum Skript</A></LI>
	<LI><A HREF="#misc">Sonstiges</A></LI>
</OL>

<H3 ID="methoden">Methoden</H3>
<UL>
	<LI CLASS="z15 z21">
		<H4 ID="q00">Was bewirken die einzelnen Methoden beim Sortieren von Arrays?</H4>
		<P>Eine Methode (auch: Funktion, Prozedur, Operation, Routine, Unterprogramm) kann man sich anschaulich vorstellen als ein wiederverwendbares Programmstück. Eine Methode kann beliebigen Code enthalten und von beliebigen Stellen aus beliebig oft aufgerufen werden. Ein Beispiel für eine Methode ist <CODE>System.out.println(String)</CODE>, die Text auf dem Bildschirm ausgibt. Methoden kann man auch selbst erstellen.</P>
		<P>Die Methoden <CODE>sort(int[])</CODE> auf den Seiten 33 und 35 in Kapitel 4 des Skript sind beides Implementationen des Selection-Sort–Algorithmus. Es besteht kein nennenswerter Unterschied zwischen den beiden. Beide Methoden sortieren den übergebenen Array aufsteigend. Auf die Funktionsweise dieses und anderer Sortieralgorithmen geht das Kapitel „Sortieren“ der Vorlesung „Algorithmen und Datenstrukturen“ ein.</P>
	</LI>
	<LI CLASS="z16">
		<H4 ID="q01">Warum nimmt man beim Sortieren vor der Zeile <CODE>public static void main (String[] args)</CODE> andere Zeilen wie <CODE>public static int[] einlesen ()</CODE>?</H4>
		<P>Bei diesen Zeilen handelt es sich um so genannte „Methodensignaturen,“ also Definitionen des Namens einer Methode sowie deren Parameter, Rückgabewert <ABBR TITLE="et cetera" LANG="la">etc</ABBR>. An sie schließt in der Regel ein Block (<CODE>{…}</CODE>) an, in dem der Algorithmus der Methode in Java beschrieben ist.</P>
		<P>In Klassen kann man beliebig viele Methoden schreiben. Die Reihenfolge, in der die Methoden dabei geschrieben werden, ist egal.</P>
		<P>Methoden werden gerne eingesetzt, um längere Algorithmen sinnvoll in kleinere Abschnitte zu unterteilen (<ABBR TITLE="so genanntes">sog.</ABBR> Top-Down–Verfahren). Vor allem aber dienen Sie der Vermeidung von Redundanzen. In diesem Fall wird die <CODE>einlesen</CODE>-Methode nur einmal aufgerufen, so dass es sich wohl nur um eine sinnvolle Aufteilung des Gesamtproblems in Teilprobleme handelt. Eine Methode zum Sortieren dagegen kann man an vielen Stellen brauchen, denn Sortiert werden muss immer irgend etwas; daher dient die <CODE>sort</CODE>-Methode in den Beispielen im Kapitel 4 durchaus auch der Vermeidung von Redundanzen.</P>
	</LI>
	<LI CLASS="z22">
		<H4 ID="q02">Was ist der Unterschied zwischen <CODE>public static void main</CODE> und <CODE>public static void sort</CODE> – <ABBR TITLE="beziehungsweise">bzw.</ABBR> wann wende ich was an?</H4>
		<P>Beides sind Teile von Methodendeklarationen (so genannten „Signaturen“). Der Unterschied ist allein der Name. Methodennamen sind (in bestimmten Grenzen) frei wählbar.</P>
		<P>Die Methode mit der Signatur <CODE>public static void main (String[])</CODE> ist diejenige, die beim Start der Klasse durch Eingabe von <CODE>java <VAR>Klassenname</VAR></CODE> im Terminal aufgerufen wird. <CODE>sort</CODE> heißt eine Methode aus dem Skript, die den Inhalt eines übergebenen Arrays sortiert.</P>
	</LI>
	<LI CLASS="z20">
		<H4 ID="q03">Welchem Zweck dienen die „<CODE>String[] args</CODE>,“ die in den Klammern der main-Methoden stehen?</H4>
		<P>Es handelt sich dabei um eine Folge von Zeichenketten, die beim Programmstart an die <CODE>main</CODE>-Methode übergeben werden. Dieses Array enthält alles, was beim Startbefehl vom Terminal aus hinter dem Programmnamen angehängt wird.</P>
		<P>Versuche mal, den gesamten Inhalt des Arrays <CODE>args</CODE> mit einer Schleife auszugeben, und ruf’ dann das Programm mit <CODE>java <VAR>Klassenname</VAR> irgendein beliebiger Text</CODE> auf!</P>
	</LI>
	<LI CLASS="z20">
		<H4 ID="q04">Warum können in Methoden die übergebenen Parameter anders heißen als beim Aufruf in der Hauptklasse, und ist es sinnvoll, diese tatsächlich anders zu nennen?</H4>
		<P>In Java haben Blöcke (von geschweiften Klammern { } eingeschlossene Code-Abschnitte) immer einen eigenen Namensraum für die Bezeichner von Variablen. Die in der Methodensignatur definierten Parameternamen gelten nur im Namensraum innerhalb der Methode.</P>
		<P>Im Gegensatz dazu können Methoden nicht nur mit Variablen, sondern mit beliebigen Werten aufgerufen werden. Im Hallo-Welt–Programm wird <ABBR TITLE="zum Beispiel">z. B.</ABBR> die <CODE>println</CODE>-Methode mit dem Wert <CODE>"Hello world."</CODE> aufgerufen.</P>
		<P>Im Beispiel der <CODE>println</CODE>-Methode kannst Du sehen, dass die Namen der Parameter eigentlich recht egal sind. Die <CODE>println</CODE>-Methode hast nämlich nicht Du geschrieben, sondern jemand anders. Nur weil der den Parameter <CODE>x</CODE> genannt hat, bedeutet nicht, dass Du das auch tun solltest.</P>
		<P>Wenn Du aber tatsächlich sowohl die Methode selbst schreibst als auch sie selbst aufrufst und dabei Variablen verwendest, bietet es sich natürlich oft an, den gleichen Namen für beides zu verwenden. Ob unterschiedliche Namen sinnvoll sind, hängt von der jeweiligen Situation ab.</P>
	</LI>
	<LI CLASS="z14">
		<H4 ID="q05">Wann schreibt man Kommata, und wann Strichpunkte (bei Argumenten)?</H4>
		<P>In Methodensignaturen und Methodenaufrufen werden mehrere Argumente (Paramter) immer durch Kommata abgetrennt. Strichpunkt stehen lediglich <EM>nach</EM> dem Methodenaufruf. Beispiel: <CODE>Circle.bigger(a, b);</CODE> (mit <CODE>a</CODE> und <CODE>b</CODE> vom Typ <CODE>Circle</CODE>)</P>
	</LI>
	<LI CLASS="z9">
		<H4 ID="q06">Was bedeutet/bewirkt das Wort <CODE>void</CODE>?</H4>
		<P>Für alle Methoden (abgesehen von dem, was Dr. Bürg „Konstruktormethode“ nennt) muss in deren Signatur („Deklaration“) der Typ des Rückgabewerts festgelegt werden. Bei Methoden, die keinen Wert mit <CODE>return</CODE> zurückgeben sollen, wird an dieser Stelle das Schlüsselwort <CODE>void</CODE> (<ABBR TITLE="englisch">engl.</ABBR> Leere, Nichts) gesetzt. Es ist also quasi der Datentyp eines nicht existierenden Werts.</P>
	</LI>
</UL>

<H3 ID="array-syntax">Arrays – Syntax, Verwendung, sonstiges</H3>
<UL>
	<LI CLASS="z8 z10 z13">
		<H4 ID="q10">Was bedeuten bei dem Sortierprogramm von Folie 34 die eckigen Klammern (<CODE>[]</CODE>) hinter <CODE>int</CODE>?</H4>
		<P>Leere eckige Klammern (<CODE>[]</CODE>) hinter Datentypen bilden einen Arraydatentyp, dessen einzelne Elemente von eben diesem Typ (hier: <CODE>int</CODE>) sind. Der Typ des Rückgabewerts <ABBR TITLE="beziehungsweise">bzw.</ABBR> Parameters ist hier <CODE>int[]</CODE>, also ein Array aus lauter Werten vom Typ <CODE>int</CODE>.</P>
	</LI>
	<LI CLASS="z12 z16">
		<H4 ID="q11">Warum schreibt man <CODE>[]</CODE> in der Zeile <CODE>public static void main (String[] args)</CODE> einmal vor dem <CODE>args</CODE> und einmal nach dem <CODE>args</CODE>?</H4>
		<P>Die Position ist in diesem Fall von der <A HREF="http://java.sun.com/docs/books/jls/second_edition/html/j.title.doc.html" HREFLANG="en">Java Language Specification</A> nicht vorgeschrieben und ist damit egal. Man darf sich also entsprechend des persönlichen Stils aussuchen, wo man’s hinschreibt. Im Allgemeinen möchte ich die Variante <EM>vor</EM> dem Parameternamen empfehlen, weil die eckigen Klammern streng genommen Teil des Typs sind (ein String-Array, <CODE>String[]</CODE>).</P>
	</LI>
	<LI CLASS="z10 z13">
		<H4 ID="q12">Kann man Arrays auch zusammen mit anderen Schleifen als for-Schleifen benutzen?</H4>
		<P>Ja. Weil Arrays eine verschieden große Anzahl von Elementen haben, die alle indiziert (also mit einer laufenden Nummer versehen) sind, werden häufig for-Schleifen verwendet, um Arrays zu durchlaufen (<ABBR TITLE="das heißt">d. h.</ABBR> nacheinander jedes Element des Arrays zu behandeln). Genau das aber geht mit jeder beliebigen Art von Schleife. Im Tutorium hatte ich schon mal erwähnt, dass for-Schleifen und while-Schleifen eigentlich das gleiche sind. Ein Array-Durchlauf ist aber auch mit einer do-while-Schleife kein Problem (wenn auch ein klein wenig umständlicher, weil man den Fall eines leeren Arrays abfangen muss).</P>
		<P>Es gibt im Übrigen sogar eine Technik, mit der man Arrays auch ganz ohne Schleifen durchlaufen kann: die Rekursion. Die wird aber (leider) nicht im Skript behandelt.</P>
	</LI>
	<LI CLASS="z16">
		<H4 ID="q13">Was bedeutet <CODE>double…[] = new double[…];</CODE> und die selbe Zeile mit anderen Bezeichnungen als <CODE>double</CODE>?</H4>
		<P>Es wird ein neuer Array mit einer bestimmten Länge erzeugt (<CODE>new double[…]</CODE>) und einer neuen Referenz mit einem bestimmten Namen (<CODE>double…[]</CODE>) zugewiesen (<CODE>=</CODE>). Dabei ist <CODE>double</CODE> der Typ des Arrays und der Referenz. Statt dessen können auch alle anderen Datentypen verwendet werden, die dann eben einen Array des betreffenden Typs beschreiben.</P>
	</LI>
	<LI CLASS="z15 z21">
		<DIV CLASS="frage" ID="q18">
			<H4>Was ist der Unterschied zwischen diesen beiden Eingabemöglichkeiten?</H4>
			<OL TYPE="a">
				<LI><CODE>l = s</CODE></LI>
				<LI><CODE>l[i] = s[i]</CODE></LI>
			</OL>
		</DIV>
		<P>Vom Wert her gibt es keinen Unterschied; beides sind Zuweisungen (keine Eingabemöglichkeiten!). Bei (a) wird der Wert einer Variablen <VAR>s</VAR> einer zweiten Variable <VAR>l</VAR> zugewiesen, bei (b) wird der Wert eines Arrayelements <VAR>s<SUB>i</SUB></VAR> einem zweiten Arrayelement <VAR>l<SUB>i</SUB></VAR> zugewiesen.</P>
	</LI>
	<LI CLASS="z9">
		<H4 ID="q14">Was passiert wenn man ein Integer-Array definiert und mit Fließkommazahlen initialisiert?</H4>
		<P>Codebeispiel: <CODE>int[] a = {1.0};</CODE></P>
		<P>Es geht schlichtweg nicht, sondern führt zu einem Compile-Zeit–Fehler (<SAMP>possible loss of precision</SAMP>), weil der Java-Compiler versucht, vor dem unbeabsichtigten Verlust der Nachkommastellen zu schützen. Bei normalen Wertzuweisungen (etwa <CODE>a[0] = 1.0;</CODE> kann man durch einen Type-Cast die Zuweisung erzwingen, wobei die Nachkommastellen weggeschmissen werden (also <CODE>a[0] = <INS>(int)</INS>1.0;</CODE>). Beim <EM>Initialisieren</EM> eines Arrays ist das aber nicht möglich; da kann man ja auch stattdessen viel einfacher den gewünschten int-Wert direkt angeben.</P>
	</LI>
	<LI CLASS="z18">
		<H4 ID="q15">Worin liegt der Unterschied, wenn ich einmal eine Matrix mit Hilfe einer 2 Dim-Matrix erzeuge und das andere mal sie aus verschiedenen Arrays zusammensetze?</H4>
		<P>Eine zweidimensionale Matrix kann in Java <ABBR TITLE="zum Beispiel">z. B.</ABBR> gut mit einem zweidimensionalen Array implementiert werden. Dann <EM>ist</EM> die Matrix zweidimensional und aus verschiedenen Arrays zusammengesetzt; es besteht also kein Unterschied.</P>
	</LI>
	<LI CLASS="z12">
		<H4 ID="q16">Für was werden Arrays verwendet?</H4>
		<P>Für alles, bei dem eine unbestimmte Anzahl von Variablen für gleichartige Werte benötigt wird. Beispiele: Zahlenfolgen, Matrizen, Sammlungen von beliebigen Objekten, Menüs in graphischen Benutzeroberflächen (für die Liste der Menüpunkte), Listen von Datensätzen einer Datenbank <ABBR TITLE="et cetera perge perge" LANG="la">etc. pp</ABBR>.</P>
		<P>Vergleiche auch die Kapitel „Statische Informationsstrukturen“ und „Dynamische Informationsstrukturen“ der Vorlesung „Algorithmen und Datenstrukturen“ im letzten Semester.</P>
	</LI>
	<LI CLASS="z15">
		<H4 ID="q17">Warum sortiert man Arrays nicht von Hand?</H4>
		<P>Das Sortieren eines Arrays von Hand ist unmöglich; man weiß vorher nicht, welche Zahlen im Array enthalten sind, und kann folglich keinen Algorithmus schreiben, der diese (unbekannten) Zahlen in die (unbekannte) richtige Reihenfolge bringt. Außerdem wäre ohnehin der Aufwand für das Sortieren von Hand unüberschaubar groß, da ja die Größe des Arrays unbekannt und im Prinzip auch unbeschränkt ist; eine Millarde Zahlen etwa kann niemand von Hand sortieren. Für einen guten Sortieralgorithmus ist das aber ein Klacks.</P>
	</LI>
</UL>

<H3 ID="array-indizes">Arrays – Indizes, Grenzen</H3>
<UL>
	<LI CLASS="z15 z21">
		<H4 ID="q20">Wie wird der <EM>Inhalt</EM> eines Arrays angesprochen und wie der <EM>Index</EM>? Was ist der Unterschied?</H4>
		<P>Der Inhalt ist jeweils der gespeicherte (oder zu speichernde) Wert, genau wie bei einer einfachen Variable. Weil in einem Array mehrere Werte gespeichert werden können, benötigt man eine Möglicheit zur Unterscheidung dieser Werte; dies ist der Index.</P>
		<P>Ähnlich wie in der Mathematik kann man die verschiedenen Arrayelemente als einzelne, durch eine laufende Nummer unterschiedene Variablen ansehen. Der Index wäre dabei ein Bestandteil der Variablennamen.</P>
		<P>Mathematische Schreibweise: <VAR>a<SUB>i</SUB></VAR>, Java-Schreibweise: <CODE>a[i]</CODE></P>
	</LI>
	<LI CLASS="z15 z21">
		<H4 ID="q21">Warum darf und kann man in ein Array der definierten Länge 5 keine 10 Elemente einfügen?</H4>
		<P>Man <EM>kann</EM> die Arraygrenzen nicht überschreiten, weil man es nicht nicht darf. Java versucht alles, was verboten ist, zu verhindern; es erscheint dann eine Fehlermeldung (hier <SAMP>ArrayIndexOutOfBoundsException</SAMP>).</P>
		<P>(Nicht alle Sprachen verhindern Verbotenes. Vor allem C ist dafür berüchtigt, prinzipbedingt überhaupt keine Überprüfung von Arraygrenzen durchzuführen. Das Programm pfuscht dann unter Umständen wild im <ABBR TITLE="Random Access Memory" LANG="en">RAM</ABBR> herum und kann Datenverluste, Abstürze und Schlimmeres verursachen.)</P>
		<P>Man <EM>darf</EM> die Arraygrenzen nicht überschreiten, weil bei der Deklaration des Arrays nur eine begrenzte Menge an Speicherplatz für den Array festgelegt wurde.</P>
		<P>(In Java sind Arraygrößen nicht veränderbar. Es gibt aber in Java andere Datenstrukturen, deren Größe beliebig verändert werden kann, etwa die des Collection-Frameworks im Paket „java.util“ (<ABBR TITLE="vergleiche">vgl.</ABBR> API-Dokumentation). Vergleiche auch das Kapitel „Dynamische Informationsstrukturen“ der Vorlesung „Algorithmen und Datenstrukturen.“)</P>
	</LI>
	<LI CLASS="z10">
		<H4 ID="q22">Wie ist es gemeint „eine Arraygrenze zu überstreiten [<ABBR TITLE="genau so im Original"><SPAN LANG="la">sic</SPAN></ABBR>!]?“</H4>
		<P>Vermutlich meinst Du „über<EM>schreiten</EM>.“ Mit dem „Überschreiten von Arraygrenzen“ ist gemeint, auf einen Array mit einem ungültigen Index zuzugreifen. Beim Erzeugen eines Arrays wird immer die Anzahl der Elemente festgelegt, und das Zählen der Indizes beginnt immer mit null. Alle Indizes, die kleiner als null oder größer als die Anzahl der Elemente des Arrays sind, sind ungültig. Beispiel: Nach der Deklaration <CODE>int a = new int[2];</CODE> ist der Zugriff auf <CODE>a</CODE> mit <CODE>a[5]</CODE> unerlaubt, da der Array nur zwei Elemente hat (nämlich <CODE>a[0]</CODE> und <CODE>a[1]</CODE>).</P>
	</LI>
	<LI CLASS="z8">
		<H4 ID="q23">Was würde passieren, wenn Arraygrenzen überschritten werden, und wie kann man das verhindern?</H4>
		<P>Das Überschreiten der Arraygrenzen ist eine so genanne Laufzeitausnahme-Situation, in der automatisch eine „Exception“ geworfen wird (hier: <CODE>ArrayIndexOutOfBoundsException</CODE>). Dies ist nichts Schlimmes und sehr oft sogar erwünscht, denn die geworfenen Exceptions kann man an anderer Stelle schön gezielt abfangen (<CODE>try</CODE> / <CODE>catch</CODE>) und gehörig behandeln (<ABBR TITLE="vergleiche">vgl.</ABBR> Kapitel 7). Daher ist es häufig nicht nötig (und manchmal auch gar nicht sinnvoll), eine Ausnahmesituation in Java zu verhindern.</P>
		<P>Möchte man das Werfen der Exception dennoch verhindern, so muss schon das Auftreten der Ausnahmesituation verhindert werden, da Java diese so genannten <CODE>RuntimeException</CODE>s automatisch wirft. Es müsste also der Wert des Arrayindizes mit <CODE>if (index &lt; <VAR>grenze</VAR>) …</CODE> geprüft werden, bevor tatsächlich damit auf den Array zugegriffen wird.</P>
	</LI>
	<LI CLASS="z14 z20">
		<H4 ID="q24">Wieviele Zeichen können in einem String maximal gespeichert werden?</H4>
		<P>Ein String ist intern als nicht veränderlicher Array von Buchstaben (<CODE>char[]</CODE>) implementiert. Es können also so viele Zeichen gespeichert werden, wie der Array lang sein kann (jedenfalls ungefähr, <ABBR TITLE="vergleiche">vgl.</ABBR> UTF-16 in <A HREF="http://www.unicode.org/versions/Unicode4.0.0/" HREFLANG="en">Unicode 4.0</A> Kapitel 3, S. 76 <ABBR TITLE="und folgende">f.</ABBR>).</P>
		<P>So weit ich das sehe, ist in der <A HREF="http://java.sun.com/docs/books/jls/second_edition/html/j.title.doc.html" HREFLANG="en">Java Language Specification</A> die Länge eines Arrays nicht definiert. Damit dürfte die maximale Länge eines Strings also nur durch den zur Verfügung stehenden Speicher abhängen. Sehr lange Strings sind jedoch vermutlich äußerst ineffizient und sollten daher vermieden werden.</P>
	</LI>
	<LI CLASS="z8">
		<H4 ID="q25">Wie kann ein Array erzeugt werden, dessen genaue Länge nicht bekannt ist (zum Beispiel bei einer Datenbank von Mitarbeitern einer Firma)?</H4>
		<P>In Java sind Arraygrößen grundsätzlich nicht veränderbar. Eine mögliche (aber naïve) Lösung wäre es, bei einer Änderung des Mitarbeiterbestands jedesmal einen neuen Array mit passender Länge anzulegen und die einzelnen Mitarbeiter in den neuen Array zu übernehmen.</P>
		<P>Sinnvolle Ansätze für das Speichern von Datenmengen unbekannter Größe behandelte das Kapitel „Dynamische Informationsstrukturen“ der Vorlesung „Algorithmen und Datenstrukturen“ im letzten Semester. Anbieten würde sich für den Fall der Mitarbeiterliste eine Lineare Liste, besser noch eine Baumstruktur.</P>
		<P>Es gibt aber auch direkt in Java geeignetere Datenstrukturen, deren Größe beliebig verändert werden kann, etwa die des Collection-Frameworks im Paket „java.util“ (<ABBR TITLE="vergleiche">vgl.</ABBR> API-Dokumentation).</P>
	</LI>
	<LI CLASS="z10 z19">
		<H4 ID="q26">Warum ist der Ausdruck <CODE><!--[-->byte<!--]--> byteDimArray [][] = new Byte[][16]</CODE> nicht zulässig?</H4>
		<P>Dafür gibt es gleich zwei Gründe:</P>
		<OL>
			<LI><P>Weil Java Groß- und Kleinschreibung unterscheidet (also „<SPAN LANG="en">case-sensitive</SPAN>“ ist), sind <CODE>byte</CODE> und <CODE>Byte</CODE> zwei verschiedene Datentypen. Konkret handelt es sich bei <CODE>byte</CODE> um den primitiven Typ für ganze Zahlen im Intervall [−128, 127], während <CODE>Byte</CODE> die gleichnamige Klasse im Paket „java.lang“ ist. Dies ist ein Fehler im Skript; es müsste darin eigentlich <CODE>byte byteDimArray [][] = new <INS>b</INS>yte[256][16]</CODE> heißen (analog auch in den anderen Beispielen dort).</P></LI>
			<LI>
				<P>Mehrdimensionale Arrays sind eigentlich <EM>geschachtelte</EM> Arrays. Mit <CODE>new byte[256][16]</CODE> wird also ein neuer Array (Typ: <CODE>byte[][]</CODE>) mit 256 Elementen erzeugt, von denen jedes einzelne <EM>nichts</EM> anderes enthält als jeweils wiederrum einen Array mit 16 Elementen. Jedes der 256 „Unter-Arrays“ ist damit vom Typ <CODE>byte[]</CODE>, während jedes der darin jeweils enthaltenen 16 Elemente den Typ <CODE>byte</CODE> hat.</P>
				<P>Arrays müssen nicht „rechteckig“ sein, <ABBR TITLE="das heißt">d. h.</ABBR> es ist möglich, die Größen der einzelnen „Unter-Arrays“ individuell zu variieren. Dazu kann man erst den „Haupt-Array“ mit den 256 Elementen erstellen und später die 256 „Unter-Arrays“ einzeln erzeugen und einfügen. Das geht dann mit dem Ausdruck <CODE>new byte[256][]</CODE>; da der Typ des Arrays zweidimensional sein soll, hier aber eigentlich ja nur ein eindimensionaler Array erzeugt werden würde, wird der Datentyp durch Anhängen eines leeren eckigen Klammerpaars (<CODE>[]</CODE>) auf einen Array von Arrays geändert.</P>
				<P>Der Ausdruck <CODE>new byte[][16]</CODE> ist ungültig, weil dabei versucht wird, „Unter-Arrays“ zu erzuegen, ohne einen „Haupt-Array“ zu haben, in den Referenzen zu den „Unter-Arrays“ abgelegt werden könnten.</P>
			</LI>
		</OL>
	</LI>
	<LI CLASS="z10">
		<H4 ID="q27">Im Skript ist von mehrdimensionalen Arrays die Rede, wo liegt hierbei das Maximum?</H4>
		<P>Da mehrdimensionale Arrays eigentlich geschachtelte Arrays sind und diese wiederrum nichts anderes als Objekte sind, die auf andere Objekte verweisen, sind der Anzahl der Dimensionen durch Java selbst keine Grenzen gesetzt.</P>
		<P>Neben dem zur Verfügung stehenden Arbeitsspeicher besteht bei Arrays mit sehr vielen Dimensionen allerdings das Problem, dass die entsprechenden Teile des Quellcodes durch unzählige eckige Klammern stark aufgeblasen werden. Auch heute noch haben viele Programme und Betriebssysteme Schwierigkeiten, mit Dateien mit mehr als 2 <ABBR TITLE="Gibibyte">GiB</ABBR> zu arbeiten, so dass vermutlich Arrays mit mehr als ein paar hundert Millionen Dimensionen problematisch sind. ;-) Ich habe das aber nie ausprobiert. So weit ich das sehe, ist in der <A HREF="http://java.sun.com/docs/books/jls/second_edition/html/j.title.doc.html" HREFLANG="en">Java Language Specification</A> auch die Länge eines Arrays nicht definiert. Damit hängt das Maximum der Größe von Arrays ausschließlich von der Umgebung ab.</P>
	</LI>
	<LI CLASS="z18">
		<H4 ID="q28">Wo wird definiert, dass bei einem zweidimensionalen Array die erste Klammer der Höhe entspricht und die zweite der Breite?</H4>
		<P>Definiert wird dies durch die Schreibrichtung der abendländischen Kultur. Wir schreiben in Zeilen von links nach rechts und fügen weitere Zeilen von oben nach unten hinzu. Mehrdimensionale Arrays sind eigentlich geschachtelte Arrays, <ABBR TITLE="das heißt">d. h.</ABBR> der erste Array enthält mehrere zweite (jeweils einen pro Zeile).</P>
		<P>Dies Zuordnung gilt übrigens nur dann, wenn die Arrays auf dem Bildschirm mit zwei geschachtelten Schleifen und der Methode <CODE>System.out.print</CODE> ausgegeben werden. Andernfalls können die Array-Inhalte durchaus auch in anderer Reihenfolge ausgelesen und ausgegeben werden.</P>
	</LI>
	<LI CLASS="z13">
		<H4 ID="q29">Was passiert wenn ich bei einem zweidimensionalen Array <CODE>i</CODE> und <CODE>j</CODE> vertausche?</H4>
		<P>Allgemein wird beim Vertauschen von Arrayindizes entweder gar nichts passieren (wenn man wirklich <EM>alle</EM> Indizes austauscht) oder es wird wahrscheinlich ein Problem geben, weil der Code nicht mehr das tut, was er soll. Möglicherwiese kommt es zu Laufzeitfehlern.</P>
	</LI>
</UL>

<H3 ID="oop">Klassen, Objekte, Datentypen</H3>
<UL>
	<LI CLASS="z8 z16 z22">
		<H4 ID="q30">Was ist der Unterschied zwischen dem Kopieren von Variablen <ABBR TITLE="beziehungseise">bzw.</ABBR> Arrays „by reference“ und „by value“?</H4>
		<P>Einige Variablentypen können nur „by reference“ kopiert werden, andere nur „by value.“ Alle primitiven Typen (<ABBR TITLE="zum Beispiel">z. B.</ABBR> <CODE>int</CODE> und <CODE>double</CODE>) können <EM>nur</EM> „by value“ kopiert werden, <EM>alle</EM> anderen dagegen <EM>nur</EM> „by reference.“ Zu diesen anderen zählen also alle Arrays (etwa <CODE>int[]</CODE>) genau so wie alle auf Klassen basierenden Typen (<ABBR TITLE="zum Beispiel">z. B.</ABBR> <CODE>String</CODE>). Vergleiche Skript Kapitel 4 Seite 16.</P>
		<P>Beim Zuweisen „by value“ wird der <EM>Wert</EM> (<ABBR TITLE="Englisch">engl.</ABBR> value) <EM>kopiert,</EM> das heißt, dass nach der Zuweisung zwei Variablen existieren, die den <EM>gleichen</EM> Wert haben.</P>
		<P>Beim Zuweisen „by reference“ wird nicht der eigentliche Wert, sondern nur die Referenz (also der „Zeiger“) auf diesen Wert kopiert, so dass nach der Zuweisung zwei Variablen existieren, die auf <EM>denselben</EM> Wert verweisen. Wird der Wert über eine der Variablen verändert, so kann man auf den geänderten Wert auch über die andere Variable zugreifen.</P>
	</LI>
	<LI CLASS="z14">
		<H4 ID="q31">Warum kann man Strings nicht mit <CODE>==</CODE> vergleichen?</H4>
		<P>Man <EM>kann</EM> Strings mit <CODE>==</CODE> vergleichen. Da Strings aber Objekte sind, vergleicht man dann auf Identität und nicht auf gleichen Inhalt. Es wird also die „reference“ verglichen, nicht der „value.“ Beispiel mit Circle aus dem Skript (gleiches Prinzip, aber einfacher zu erklären):</P>
		<BLOCKQUOTE><PRE><CODE>Circle a = new Circle();
a.r = 5;
Circle b = a;  <SPAN CLASS="comment">// Zuweisung by reference</SPAN>
System.out.println(a == b);  <SPAN CLASS="comment">// true</SPAN>
System.out.println(b.r);  <SPAN CLASS="comment">// 5</SPAN>
a.r = 2;
System.out.println(b.r);  <SPAN CLASS="comment">// 2</SPAN></CODE></PRE></BLOCKQUOTE>
		<P>Hier existiert nur <EM>ein</EM> <CODE>Circle</CODE>-Objekt – schließlich wird ja auch der Konstruktur nur einmal aufgerufen! <CODE>a</CODE> und <CODE>b</CODE> zeigen auf <EM>dieselbe</EM> Instanz, folglich sind Änderungen unabhängig von der Referenz (<CODE>a</CODE> oder <CODE>b</CODE>), die zum Zugriff auf die Instanz verwendet wird, immer wirksam und sichtbar.</P>
		<BLOCKQUOTE><PRE><CODE>String a = "test";  <SPAN CLASS="comment">// gleichwertig mit …= new String("test");</SPAN>
String b = "test";  <SPAN CLASS="comment">// gleichwertig mit …= new String("test");</SPAN>
System.out.println(a == b);  <SPAN CLASS="comment">// false</SPAN></CODE></PRE></BLOCKQUOTE>
		<P>Für Strings, die mit Anführungszeichen direkt in den Code geschrieben werden (<CODE>"test"</CODE>), wird immer automatisch von Java eine neue Instanz erstellt, so als ob man den Konstruktor der String-Klasse aufrufen würde. Daher werden hier eigentlich zwei (versteckte) „Konstruktoren“ aufgerufen, also auch zwei verschiedene Instanzen erstellt. Und die können trotz „zufälligerweise“ gleichem Inhalt nicht identisch sein, daher liefert <CODE>a == b</CODE> hier immer <CODE>false</CODE> zurück.</P>
		<P>(Anmerkung: Diese Antwort ignoriert String-Internierung, die in Java konstante Strings vergleichbar macht; vgl. <A HREF="http://java.sun.com/docs/books/jls/second_edition/html/lexical.doc.html#19369" HREFLANG="en">JLS<SUP>2</SUP> 3.10.5:7</A> und <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html#intern()" HREFLANG="en">String#intern()</A>.)
	</LI>
	<LI CLASS="z8">
		<H4 ID="q32">Wie kann das Programm von Folie 34 <ABBR TITLE="folgende">ff.</ABBR> in natürlicher Sprache wiedergegeben werden?</H4>
		<P>Indem zunächst die Klassenstruktur mit ihren Variablen und Methoden allgemein beschrieben wird (<ABBR TITLE="vergleiche">vgl.</ABBR> Vorlesung „Algorithmen und Datenstrukturen“) und anschließend die einzelnen Methoden jeweils für sich in natürlicher Sprache beschrieben werden.</P>
	</LI>
	<LI CLASS="z18">
		<H4 ID="q33">Wie konvertiere ich einen Datentyp in einen anderen?</H4>
		<P>Einige Datentypen sind zueinander kompatibel; diese kann man ineinander „casten,“ indem man den Zieldatentyp in runden Klammern vor den umzuwandelnden Wert schreibt. Im folgenden Beispiel ist also <CODE>(int)</CODE> der Type-Cast:</P>
		<P><CODE>double kommazahl = 3.8;<BR>
		int ganzzahl = (int)kommazahl;</CODE></P>
		<P>Im Beispiel wird die Zahl 3,8 in eine Ganzzahl konvertiert. Die Variable <CODE>ganzzahl</CODE> enthält hinterher den Wert 3.</P>
		<P>Nicht unmittelbar zueinander kompatible Typen muss man „per Hand“ umwandeln. Die Vorgehensweise ist entscheidend von den jeweiligen Typen abhängig. Beispielsweise kann die Methode <CODE>Integer.parseInt(String)</CODE> einen als Parameter übergebenen Wert vom Typ <CODE>String</CODE> in den Typ <CODE>int</CODE> konvertieren. In vielen Fällen gibt es aber noch keine passende Methode zum Konvertieren; die muss man sich dann selber schreiben.</P>
	</LI>
	<LI CLASS="z18 z16 z22">
		<H4 ID="q34">Was bedeutet die Methode <CODE>Integer.parseInt</CODE> aus der Klasse <CODE>Utils</CODE>?</H4>
		<P>Streng genommen wird die Methode <CODE>parseInt(String)</CODE> in der Klasse <CODE>Integer</CODE> definiert. <CODE>Integer</CODE> ist Bestandteil von Java und in der API-Dokumentation beschrieben (im Paket „java.lang“). <CODE>Utils</CODE> verwendet <CODE>Integer.parseInt(String)</CODE>, um eine in Textform vorliegende Zahl in eine Zahl vom Typ <CODE>int</CODE> umzuwandeln, mit der man dann auch rechnen kann.</P>
	</LI>
</UL>

<H3 ID="pakete">Pakete</H3>
<UL>
	<LI CLASS="z15 z21">
		<H4 ID="q40">Was bedeutet das „public“ vor class und welche Funktion hat es?</H4>
		<P><CODE>public</CODE> ermöglicht den Zugriff auf das Programm auch aus anderen Paketen heraus. Pakete werden bei größeren Softwareprojekten in Java zur Codeorganisation eingesetzt; in dieser Vorlesung benötigten wir sie noch nicht. Dennoch möchte ich aus bestimmten Gründen empfehlen, vorerst alle Klassen, Methoden <ABBR TITLE="et cetera" LANG="la">etc.</ABBR> <CODE>public</CODE> zu deklarieren. Vergleiche Skript Kapitel 6, Seite 36.</P>
	</LI>
	<LI CLASS="z20">
		<H4 ID="q41">Können die Unterklassen auch in anderen Textdokument abgespeichert werden als die Hauptklasse?</H4>
		<P>Ja (mit der Ausnahme von <ABBR TITLE="so genannten">sog.</ABBR> „inneren Klassen,“ die Ihr aber frühestens im nächsten Semester behandelt).</P>
	</LI>
	<LI CLASS="z20">
		<H4 ID="q42">Welche Wirkung/Probleme ergeben sich dann durch den Aufruf der Unterklassen?</H4>
		<P>Keine, sofern die Dateinamen mit den Klassennamen übereinstimmen (wie immer einschließlich Groß- und Kleinschreibung) und alle Dateien im selben Verzeichnis liegen. Um Quelltextdateien auf mehrere Verzeichnisse aufzuteilen, muss mit Paketen und Sichtbarkeitsmodifikatoren gearbeitet werden (<ABBR TITLE="vergleiche">vgl.</ABBR> Skript Kapitel 6, Seite 36 <ABBR TITLE="und folgende">f.</ABBR>).</P>
	</LI>
</UL>

<H3 ID="skript">Fragen zum Skript</H3>
<UL>
	<LI CLASS="z8 z22">
		<H4 ID="q50">Kapitel 4, Seite 9: Was bedeutet <CODE>nums[i] = Math.random() * 100</CODE> in Zeile 5?</H4>
		<P><CODE>Math.random()</CODE> erstellt eine Pseudo-Zufallszahl im Intervall [0, 1). <CODE>Math.random() * 100</CODE> erweitert dieses Intervall auf [0, 100). Mit <CODE>=</CODE> wird diese Zufallszahl dann der Variablen <CODE>nums[i]</CODE> zugewiesen, wobei <CODE>nums</CODE> ein Array ist und <CODE>i</CODE> der Index desjenigen Array-Elements, dessen Wert durch die Zufallszahl ersetzt werden soll.</P>
		<P>Die gesamte for-Schleife sorgt also dafür, dass der gesamte Array <CODE>nums</CODE> mit Zufallszahlen im Bereich zwischen 0 und 100 gefüllt wird.</P>
	</LI>
	<LI CLASS="z8 z9">
		<H4 ID="q51">Kapitel 4, Seite 18: Wie komme ich auf die Zeile 13: <CODE>System.arraycopy(a, 0, b, 0, a.length);</CODE>? Und was bedeutet sie?</H4>
		<P>Bei dieser Zeile handelt es sich um den Aufruf einer Klassenmethode aus der Klasse <CODE>System</CODE>, die Bestandteil von Java ist. An dieser Stelle der Vorlesung wurde eine einfache Art und Weise benötigt, einen Array „by value“ zu kopieren. Das kann man auch einfach selbst machen, indem man mit einer Schleife alle Elemente des Arrays durchläuft und jedes einzeln „by value“ kopiert. In diesem Fall hat Dr. Bürg jedoch statt dessen auf eine bereits existierende Methode, die intern genau das macht, zurück gegriffen. <EM>Er</EM> wusste bereits, dass eine solche Methode in der Klasse <CODE>System</CODE> existiert.</P>
		<P>Um selbst so eine Methode zu finden, muss man in der <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/" HREFLANG="en">Dokumentation der Java-API</A> suchen. In deren Index kann man durch geschicktes Suchen die arraycopy-Methode durchaus finden. Etwas einfacher ist es, gezielt auf der Website von Sun <A HREF="http://www.google.de/search?q=array+copies+site:java.sun.com" TITLE="mit Google nach „array copies“ auf java.sun.com suchen">mit Google zu suchen</A>. So oder so gelangt man schließlich in die Dokumentation der Klasse <CODE><A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/System.html" HREFLANG="en" TITLE="Dokumentation der System-Klasse">System</A></CODE>, in deren alphabetischer Methodenliste dann ganz oben die <A HREF="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/System.html#arraycopy(java.lang.Object, int, java.lang.Object, int, int)" HREFLANG="en" TITLE="Dokumentation der arraycopy-Methode">arraycopy-Methode</A> steht.</P>
		<P>Dort ist die Arbeistweise der Methode mitsamt der Bedeutung der Parameter (Argumente) genau erklärt. Kurz gefasst wird ein Teil des im ersten Parameter übegebenen Arrays (hier <CODE>a</CODE>) in den Array im dritten Parameter (<CODE>b</CODE>) kopiert. Der kopierte Teil beginnt bei der durch den zweiten Parameter angegeben Stelle in <CODE>a</CODE> (<CODE>0</CODE>) und wird in <CODE>b</CODE> beginnend an der Stelle des vierten Parameters eingesetzt (<CODE>0</CODE>). Die Anzahl der zu kopierenden Elemente wird als letzter Parameter übergeben (hier <CODE>a.length</CODE>).</P>
		<P>Folglich wird in dieser Zeile im Skript der gesamte Arrayinhalt von <CODE>a</CODE> in den Array <CODE>b</CODE> kopiert.</P>
	</LI>
	<LI CLASS="z8">
		<H4 ID="q52">Kapitel 4, Seite 26: Was bedeuten die beiden aufeinander folgenden Gleichheitszeichen in Zeile 7: <CODE>if (i == j)  matrix[i][j] = 1;</CODE>?</H4>
		<P><CODE>==</CODE> ist in Operator, der zwei Werte auf Gleichheit prüft und dessen Ergebnis („gleich“ oder „ungleich“) den Typ <CODE>boolean</CODE> (Wert <CODE>true</CODE> oder <CODE>false</CODE>) hat. <CODE>==</CODE> gehört damit zu den Vergleichsoperatoren (wie auch etwa <CODE>&lt;</CODE> oder <CODE>>=</CODE>). Eine Liste einiger gängiger Operatoren befindet sich im Skript im Kapitel 3 auf Folie 5; entgegen der Überschrift enthält die Liste aber nicht nur arithmetische, sondern auch andere Operatoren.</P>
		<P>Zu beachten ist der Unterschied zwischen dem Vergleichen „by reference“ und „by value.“ Außerdem darf <CODE>==</CODE> nicht mit dem Zuweisungsoperator <CODE>=</CODE> verwechselt werden! Beispiel:</P>
		<BLOCKQUOTE><PRE><CODE>int a = 0;
System.out.println(a == 0);  <SPAN CLASS="comment">// true</SPAN>
System.out.println(a == 1);  <SPAN CLASS="comment">// false</SPAN>
System.out.println(a);  <SPAN CLASS="comment">// 0</SPAN>
System.out.println(a = 1);  <SPAN CLASS="comment">// 1</SPAN>
System.out.println(a);  <SPAN CLASS="comment">// 1</SPAN></CODE></PRE></BLOCKQUOTE>
		<P>Das Ergebnis des Ausdrucks <CODE>a = 1</CODE> ist also nicht vom Typ <CODE>boolean</CODE>, sondern nimmt Typ und Wert der Variablen an. Üblicherweise steht eine Zuweisung wie <CODE>a = 1;</CODE> als eigene Anweisung in einer eigenen Zeile. Sie kann jedoch auch an anderen Stellen stehen, was gelegentlich zu Verwirrung führt.</P>
	</LI>
	<LI CLASS="z18">
		<H4 ID="q53">Kapitel 4, Seite 27: Was ist die <CODE>main</CODE>-Methode, was ist die <CODE>sort</CODE>-Methode?</H4>
		<P>Die <CODE>main</CODE>-Methode ist diejenige Methode, die beim Programmstart mit <CODE>java ArraySortMeth</CODE> aufgerufen wird. Die <CODE>sort</CODE>-Methode sortiert den übergebenen Array aufsteigend mit Hilfe des Selection-Sort–Algorithmus (<ABBR TITLE="vergleiche">vgl.</ABBR> Kapitel „Sortieren“ der Vorlesung „Algorithmen und Datenstrukturen“).</P>
	</LI>
	<LI CLASS="z8 z22">
		<H4 ID="q54">Kapitel 4, Seite 27: Was bedeuten die Worte <CODE>short</CODE> und <CODE>triangle</CODE> und wie komme ich darauf?</H4>
		<P><CODE>short</CODE> ist ein Schlüsselwort, das für einen bestimmten primitiven Datentyp (ähnlich <CODE>int</CODE>, den man hier stattdessen hätte wählen können) steht. Möchte man Zahlen in Variablen speichern, so muss immer darauf geachtet werden, dass der Zahlenbereich des Variablytyps ausreichend ist; bei <CODE>int</CODE> hat man da erfahrungsgemäß nur selten Probleme. Vergleiche Skript Kapitel 1 Folie 1.</P>
		<P><CODE>triangel</CODE> ist im Skript der Name eines (zweidimensionalen) Arrays aus Zahlen vom Typ <CODE>short</CODE>. Variablennamen sind (in bestimmten Grenzen) frei wählbar.</P>
	</LI>
</UL>

<H3 ID="misc">Sonstiges</H3>
<UL>
	<LI CLASS="z12">
		<H4 ID="q60">Welche mathematischen Funktionen beherrscht Java?</H4>
		<P>Welche mathematischen Operationen die <EM>Sprache</EM> Java beherrscht, ist in der Java Language Specification im Kapitel über <A HREF="http://java.sun.com/docs/books/jls/second_edition/html/typesValues.doc.html#51035" HREFLANG="en">Typen, Werte und Variablen</A> festgelegt. Einige davon sind auch im Skript enthalten. Auf Fließkommazahlen können weniger Operatoren als auf Ganzzahlen angewandt werden.</P>
		<P>Darüber hinaus unterstützt die <EM>Entwicklungsumgebung</EM> (genauer: das „Framework“) Java eine Reihe weiterer Operationen; diese sind in der API-Dokumentation zu finden (interessant sind vor allem die Klassen <CODE>Math</CODE> sowie <CODE>BigInteger</CODE> und <CODE>BigDecimal</CODE> im Paket „java.lang“). Da sich aber <EM>alle</EM> numerischen mathematischen Funktionen und Operationen auf die „Grundrechenarten“ zurückführen lassen, die die Sprache Java unterstützt, kann man letztlich <EM>beliebige</EM> numerische Operationen mit Java ausführen – einige davon muss man Java aber erst durch Schreiben einer entsprechenden Methode selbst beibringen.</P>
	</LI>
	<LI CLASS="z12">
		<H4 ID="q61">Kann Java mit Matrizen rechnen?</H4>
		<P>In der Sprache Java gibt es keine Matrizen; eine passende Datenstruktur muss man selbst entwickeln, etwa einen zweidimensionalen Array. Auf Arrays lassen sich aber keine der mathematischen Operatoren von Java anwenden, so dass man selbst Methoden für das Rechnen mit Matrizen schreiben muss. Das ist aber eigentlich nicht sonderlich schwierig (wäre eine nette Übungsaufgabe!). Auf diese Weise kann man Java leicht beibringen, mit Matrizen zu rechnen.</P>
	</LI>
	<LI CLASS="z9">
		<H4 ID="q62">Wieso wird die erzeugte Zufallszahl in den Sortier-Beispielen mit 10 
multipliziert?</H4>
		<P><CODE>Math.random()</CODE> erstellt eine Pseudo-Zufallszahl im Intervall [0, 1). <CODE>Math.random() * 10</CODE> erweitert dieses Intervall auf [0, 10). In den Sortier-Beispielen werden Arrays von Ganzzahlen sortiert, wofür Zufallszahlen im Intervall [0, 1) ungeeignet sind; daher muss dieses Intervall vergrößert werden. Letztenendes ergeben sich dann Zufalls-Ganzzahlen im Bereich zwischen 0 (einschließlich) und 10 (ausschließlich).</P>
	</LI>
	<LI CLASS="z14">
		<H4 ID="q63">Was bedeutet der Begriff „parse“?</H4>
		<P>Frei übersetzt aus dem New Oxford American Dictionary:</P>
		<BLOCKQUOTE>
			<P>• einen String oder Text analysieren und in logische oder syntaktische Teile zerlegen, häufig um auf Übereinstimmung mit einer logischen Grammatik hin zu prüfen</P>
		</BLOCKQUOTE>
		<P>Im Falle von <CODE>Integer.<EM>parse</EM>Int(String)</CODE> geht es also darum, die einzelnen Ziffern aus dem übergebenen String zu extrahieren und sinnvoll (also entsprechend der üblichen dezimalen Arithmetik) zu einer Zahl, mit der man dann später was rechnen kann, zusammenzufügen.</P>
	</LI>
	<LI CLASS="z14">
		<H4 ID="q64">Gibt es einen Java-Befehl zum Löschen des Bildschirms?</H4>
		<P>Nein. Allerdings ist es wahrscheinlich möglich, die Fähigkeiten des Terminals mit <CODE>terminfo(5)</CODE> oder so abzufragen und dann irgendwelche Codes an <CODE>System.out</CODE> auszugeben, die dann das Terminalfenster „löschen.“ Ich habe aber keine Ahnung, wie das konkret geht. Fragt vielleicht nächstes Semester mal in der Vorlesung „Betriebssysteme“…</P>
	</LI>
	<LI CLASS="z13">
		<H4 ID="q65">Brauche ich hinter einer for-Schleife eine geschweifte Klammer?</H4>
		<P>Eine for-Schleife besteht aus der Deklaration (beispielsweise <CODE>for ( ; ; )</CODE>) und dem zu wiederholenden Code. Um bei <EM>mehreren</EM> zu wiederholenden Codezeilen deren zugehörigkeit zur Schleife zu kennzeichnen, müssen diese in einen Block (<CODE>{ … }</CODE>) gesetzt werden; bei einer einzelnen Anweisung ist das nicht unbedingt nötig.</P>
		<P>Man braucht die geschweiften Klammern bei for-Schleifen also nur dann, wenn mehr als eine Anweisung wiederholt werden soll. Es ist trotzdem <EM>dringenst</EM> zu empfehlen, bei allen Schleifen, Bedingungen <ABBR TITLE="et cetera" LANG="la">etc.</ABBR> <EM>immer</EM> geschweifte Klammern zu schreiben! Tut man das nicht, ist der Code nicht nur uneinheitlicher und damit unübersichtlicher, sondern vor allem viel schwieriger zu verändern, weil sich der Bearbeiter beim Hinzufügen von Zeilen nun plötzlich auch über eventuell fehlende Klammern Gedanken machen muss.</P>
	</LI>
	<LI CLASS="z13">
		<H4 ID="q66">Wieso funktioniert es nicht, eine Variable mit <CODE>int i;</CODE> zu initialisieren und ihr in einer for-schleife erst den Wert zuzuweisen?</H4>
		<P>Mit <CODE>int i;</CODE> wird die Variable <CODE>i</CODE> ja gerade eben <EM>nicht</EM> initialisiert! Das ist nur eine reine <EM>Deklaration.</EM> „Initialisieren“ bedeutet „einen Anfangswert zuweisen.“</P>
		<P>Grundsätzlich kann man durchaus auch nicht initialisierten Variablen erst in einer Schleife einen Wert zuweisen. Allerdings darf man dann nicht lesend auf die Variable zugreifen, solange nicht absolut sicher ist, dass ihr zuvor tatsächlich ein Wert zugewiesen worden ist. Das kann gerade bei Schleifen und Bedingungen manchmal zu Verwirrung führen, weswegen es keine schlechte Idee ist, alle Variablen gleich bei der Deklaration zu initialisieren.</P>
	</LI>
	<LI CLASS="z9">
		<H4 ID="q67">Warum wird bei den for-Schleifen nur bis <CODE>i &lt; <VAR>Arraylänge</VAR></CODE> wiederholt?</H4>
		<P>Weil man die obere Grenze des Arrays nicht überschreiten kann und darf und weil die Zählung des Indizes bei null beginnt, muss es bei Arraydurchläufen eine Abbruchbedingung geben, die den Zugriff auf den Array mit einem Index größer oder gleich der Arraylänge verhindert.</P>
		<P>Es gibt noch mindestens drei alternative Bedingungen neben <CODE>i &lt; <VAR>Arraylänge</VAR></CODE>, die dieses Ziel ebenfalls erreichen. Edsger Wybe Dijkstra hat schon 1982 die Vor- und Nachteile dieser Varianten kurz gegenüber gestellt und kam zu dem Schluss, dass <CODE>i &lt; <VAR>Arraylänge</VAR></CODE> tatsächlich die einzig sinnvolle Art und Weise ist. Vergleiche <A HREF="http://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF" HREFLANG="en" LANG="en" TYPE="application/pdf">E. W. Dijkstra, <EM>Why numbering should start at zero,</EM> Nuenen 1982, Edsger W. Dijkstra Archive #831</A> (PDF).</P>	</LI>
</UL>

<ADDRESS ID="author">Arne Johannessen, 15. Juni 2006</ADDRESS>

<DIV ID="menu"><HR CLASS="hide"><STRONG CLASS="hide">Menü:</STRONG><UL>
	<LI><A HREF="./">Übersicht</A></LI>
	<LI><A HREF="termine.html">Termine</A></LI>
	<LI><A HREF="bewertung.html">Bewertung</A></LI>
</UL><HR><UL>
	<LI><A HREF="handzettel/">Handzettel</A></LI>
	<LI><STRONG TITLE="die Seite „Fragen und Antworten“ wird gerade angezeigt">Fragen und Antworten</STRONG></LI>
	<LI><A HREF="utils.html"><EM>Utils.class</EM></A></LI>
	<LI><A HREF="handzettel/3/"><EM>BlueJ</EM></A></LI>
</UL><HR><UL>
	<LI><A HREF="kontakt.html">Kontakt</A></LI>
	<LI><A HREF="impressum.html">Datenschutz<BR>Impressum</A></LI>
</UL><HR></DIV>

</BODY></HTML>
